---
title: "Using the iso8601 functions"
author: "Colin Smith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Data interoperability is improved by the adoption of standard date and time formats. To facilitate use of the ISO 8601 standard, we've developed functions for converting to a subset of ISO 8601 formats, for reporting ISO 8601 format specifiers, and for reading ISO 8601 into R as POSIXct and POSIXt. This vignette provides an overview of these functions and demonstrates their capabilities.

```{r instload dataCleanr, message=FALSE, warning=FALSE}
# Install and load dataCleanr

# devtools::install_github('EDIorg/dataCleanr')
library(dataCleanr)

```

## Conversion

`iso8601_convert` converts date and time character strings to the standard ISO 8601 format, with the output resolution matching the input resolution, and full support of timezone offsets. This function does not convert to all ISO 8601 formats. Currently supported formats include calendar dates, times, time zones, and valid combinations of these. Week dates, ordinal dates, and time intervals are not yet supported.

`iso8601_convert` leverages the power of `lubridate::parse_date_time` to parse dates and times, then uses regular expressions on the user supplied `orders` argument to identify resolution of the input data, and then outputs the converted data in this same resolution. Most of the arguments available to `lubridate::parse_date_time` can be used with `iso8601_convert`.

A common data management issue is converting date and time data into a consistent format. The following example illustrates some issues encountered in this process and how to solve them with `iso8601_convert`.

```{r one format, echo=TRUE, paged.print=TRUE}
# Load the example data and view the first few lines to identify datetime orders

x <- data_iso8601$datetime
head(x)

# Convert the data using 'mdy HM' orders

x_cnv <- iso8601_convert(x, orders = 'mdy HM')
x_cnv
```

Looks like the orders didn't fully describe the input data. NAs are returned where parsing failed. We can use these to view what wasn't processed and why.

```{r datetimes use NA, echo=TRUE, paged.print=TRUE}
# View data that wasn't parsed

x[is.na(x_cnv)]

# There are two orders present in these data, 'mdy H' and 'dmy HM'. Try converting with an updated list of orders.

x_cnv <- iso8601_convert(x, orders = c('mdy H', 'mdy HM', 'dmy HM'))
x_cnv
```

Notice, all the dates and times were parsed and output in resolution of the input data. Suppose we want to force the output resolution to be equal across all records. To do this, set the orders to the same resolution and set the `truncated` argument to the number of missing formats.

```{r datetimes truncated, echo=TRUE, paged.print=TRUE}
# Adjust arguments to output data in the same resolution.

x_cnv <- iso8601_convert(x, orders = c('mdy HM', 'mdy HM', 'dmy HM'), truncated = 1)
x_cnv

```

Time zone offsets are added as a two digit hour with a '+' or '-' with respect to UTC.

```{r datetimes timezone, echo=TRUE, paged.print=TRUE}
# Add a time zone offset

x_cnv <- iso8601_convert(x, orders = c('mdy HM', 'mdy HM', 'dmy HM'), truncated = 1, tz = '-05')
x_cnv
```

Voila! Dates and times in an ISO 8601 standard format.

## Get the datetime format string

Another common data management task is to identify and report the format string specifier (e.g. 'YYYY-MM-DD') for a vector of date and time data. While not particularly difficult to do, automating this task can improve workflow efficiency and accuracy. 

`iso8601_get_format_string` uses regular expressions to parse input data and identify the format string(s) present in a set of ISO 8601 dates and times in the format output by `iso8601_convert`.

```{r format string detection, echo=TRUE, paged.print=TRUE}
# Get the format string of the processed date and time data

iso8601_get_format_string(x_cnv)

# If there were more than one date time format present, then the mode is returned with a warning message.

x_different_formats <- c('2012-05-15T13:45:00', '2012-06-15T13:45:00', '2012-07-15T13:45:00', '2012-08-15T13:45', '2012-09-15T13:45', '2012-10-15T13')

iso8601_get_format_string(x_different_formats)

```

## Reading into POSIXct POSIXt

`iso8601_read` provides a lightweight option for reading ISO 8601 data "as is" in the POSIXct POXIXt class. Use `lubridate::parse_date_time` for more options on handling time zone offsets and locales.

```{r read, echo=TRUE, paged.print=TRUE}
# Read data into POSIXct POSIXt

# Read data into R
x_pos <- iso8601_read(x_cnv)
attributes(x_pos)
```

Now that the data are in POSIX, the myriad of date and time functions of `lubridate` are available to you.
